<%
/*
 * Copyright (c) 2016, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
 *
 *   WSO2 Inc. licenses this file to you under the Apache License,
 *   Version 2.0 (the "License"); you may not use this file except
 *   in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing,
 *   software distributed under the License is distributed on an
 *   "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *   KIND, either express or implied.  See the License for the
 *   specific language governing permissions and limitations
 *   under the License.
 */

include("/jagg/jagg.jag");
include("/jagg/constants.jag");

var log = new Log("module/application/application.jag");
var modManager = jagg.module("manager");
var ApplicationManager = Packages.org.wso2.appcloud.core.ApplicationManager;
var Application = Packages.org.wso2.appcloud.core.dto.Application;
var Version = Packages.org.wso2.appcloud.core.dto.Version;
var KubernetesProvisioningUtils =  Packages.org.wso2.appcloud.provisioning.runtime.Utils.KubernetesProvisioningUtils;
var EventsManager = Packages.org.wso2.appcloud.core.EventsManager;
var Event = Packages.org.wso2.appcloud.core.dto.Event;
var Deployment = Packages.org.wso2.appcloud.core.dto.Deployment;
var Container = Packages.org.wso2.appcloud.core.dto.Container;
var ServiceProxy = Packages.org.wso2.appcloud.core.dto.ContainerServiceProxy;
var CloudUtil = Packages.org.wso2.appcloud.common.util.AppCloudUtil;
var RuntimeProperty = Packages.org.wso2.appcloud.core.dto.RuntimeProperty;
var CarbonUtils = Packages.org.wso2.carbon.utils.CarbonUtils;
var Util = Packages.org.wso2.appcloud.core.Util;

/**
 * Add an application via GitHub repo and branch
 *
 */

var addApplicationViaGitHub = function (applicationName, versionName, applicationDescription, replicas,
                                        runtimeId, appTypeName, runtimePropertiesArray, tagArray, appIcon, gitHubRepoUrl, gitHubRepoBranch) {

    log.info("Started creating App => name : " + applicationName + " Version : " + versionName + " Description " +
             ": " + applicationDescription + " runtimeId : " + runtimeId + " apptype : " + appTypeName );

    var tenantId = modManager.getTenantId();
    var applicationHashId = Util.getApplicationHashId(applicationName, tenantId);
    var versionHashId = Util.getVersionHashId(applicationName, versionName, tenantId);
    var application = createAppInDataBase(applicationName, versionName, applicationDescription, replicas, runtimeId, appTypeName,
                                          runtimePropertiesArray, tagArray, appIcon, applicationHashId, versionHashId);
    var applicationRuntime = ApplicationManager.getRuntimeById(runtimeId);
    var tagName = applicationRuntime.getTag() +"-"+ modManager.getTenantDomain() +"-"+applicationName+"-"+versionName;
    var DockerOpClient = Packages.org.wso2.appcloud.core.docker.DockerOpClient;
    var dockerOpClient = new DockerOpClient(modManager.getPropertyValue("DockerClientURL"));
    var version = application.getVersions().get(0);
    var runtimeProperties = version.getRuntimeProperties();

    var absFileUploadedPath =  createDockerFileForGitHub(applicationName, versionName, runtimeId, gitHubRepoUrl, gitHubRepoBranch, versionHashId, dockerOpClient);
    buildDockerImage(applicationName, versionName, runtimeId, absFileUploadedPath, applicationRuntime, tagName, versionHashId, dockerOpClient);
    pushDockerImage(applicationName, versionName, applicationRuntime, tagName, versionHashId, dockerOpClient);
    triggerKubernetesDeployment(runtimeProperties, applicationRuntime, tagName, applicationName, versionName, runtimeId, replicas, versionHashId);
};

/**
 * Add an application object
 *
 * @param applicationName name of the application
 * @param versionName revision number of the application
 * @param applicationDescription description of the application
 * @param replicas no of replicas
 * @param uploadedArtifact the uploaded artifact file
 * @param runtimeId runtime id of the application
 */
var addApplication = function (applicationName, versionName, applicationDescription, replicas,
                               runtimeId, appTypeName, runtimePropertiesArray, tagArray, appIcon, uploadedFileName) {

    log.info("Started creating App => name : " + applicationName + " Version : " + versionName + " Description " +
             ": " + applicationDescription + " runtimeId : " + runtimeId + " apptype : " + appTypeName );

    var tenantId = modManager.getTenantId();
    var applicationHashId = Util.getApplicationHashId(applicationName, tenantId);
    var versionHashId = Util.getVersionHashId(applicationName, versionName, tenantId);
    var application = createAppInDataBase(applicationName, versionName, applicationDescription, replicas, runtimeId, appTypeName,
                                          runtimePropertiesArray, tagArray, appIcon, applicationHashId, versionHashId);
    var applicationRuntime = ApplicationManager.getRuntimeById(runtimeId);
    var tagName = applicationRuntime.getTag() +"-"+ versionHashId;
    var DockerOpClient = Packages.org.wso2.appcloud.core.docker.DockerOpClient;
    var dockerOpClient = new DockerOpClient(modManager.getPropertyValue("DockerClientURL"));
    var version = application.getVersions().get(0);
    var runtimeProperties = version.getRuntimeProperties();


    var absFileUploadedPath =  createDockerFile(applicationName, versionName, runtimeId, uploadedFileName, versionHashId, dockerOpClient);
    buildDockerImage(applicationName, versionName, runtimeId, absFileUploadedPath, applicationRuntime, tagName, versionHashId, dockerOpClient);
    pushDockerImage(applicationName, versionName, applicationRuntime, tagName, versionHashId, dockerOpClient);
    triggerKubernetesDeployment(runtimeProperties, applicationRuntime, tagName, applicationName, versionName, runtimeId, replicas, versionHashId);
};

var triggerKubernetesDeployment = function(runtimeProperties, applicationRuntime, tagName, applicationName, versionName, runtimeId, replicas, versionHashId){
    var containers = getContainers(applicationRuntime.getRepoURL(), applicationRuntime.getImageName(), tagName, versionHashId ,versionHashId, runtimeProperties, runtimeId);
    var deploymentConfig = getDeploymentConfig(containers, versionHashId, replicas);
    deployApplication(applicationName, versionName, deploymentConfig, false, versionHashId);

}

var pushDockerImage = function (applicationName, versionName, applicationRuntime, tagName, versionHashId, dockerOpClient){

    //Adding docker image push pending event
    var msg = "Docker image push successfully triggered in triggered";
    addEvent(DOCKER_REGISTRY_PUSH, EVENT_PENDING, msg, versionHashId);

    try {

        dockerOpClient.pushDockerImage(applicationRuntime.getRepoURL(),applicationRuntime.getImageName(), tagName);

    } catch (e) {

        var msg = "Error uploading docker image to remote registry";
        addEvent(DOCKER_REGISTRY_PUSH, EVENT_FAILED, msg, versionHashId);

        try {
            ApplicationManager.updateVersionStatus(versionHashId, APPLICATION_ERROR);
        } catch(e1){
            log.error("Error while updating Application Creation Failed event for application : " + applicationName
                              + " version : " + versionName);
            log.error(e1);
            // not throwing the error, because it will hide the actual exception
        }

        log.error(msg);
        log.error(e);
        log.info("Application creation failed because docker image push failed and roll back process" +
                 " is started for application : "+applicationName+" with revision : "+versionName);
        deleteApplicationUploadedPath(applicationName, versionName);
        deleteApplicationFromDatabase(versionHashId);
        throw e;
    }

    //Adding docker push success event
    var msg = "Docker image push successfully completed";
    addEvent(DOCKER_REGISTRY_PUSH, EVENT_SUCCEEDED, msg, versionHashId);
}

var buildDockerImage = function (applicationName, versionName, runtimeId, absFileUploadedPath, applicationRuntime, tagName, versionHashId, dockerOpClient){

    //Adding docker build pending event
    var msg = "Docker image build successfully triggered in appcloud";
    addEvent(DOCKER_IMAGE_BUILD, EVENT_PENDING, msg, versionHashId);

    var applicationRuntime = ApplicationManager.getRuntimeById(runtimeId);
    var tenantDockerRegistryUrl = modManager.getPropertyValue(PROPERTY_DOCKER_REGISTRY_URL) + "/" + dockerRegTenantSpace;
    var tagName = applicationRuntime.getTag() +"-"+ versionHashId;

    try {

        var dockerRegTenantSpace = modManager.getTenantDomain().replace(".","-");
        dockerOpClient.buildDockerImage(applicationRuntime.getRepoURL() ,applicationRuntime.getImageName(), tagName, absFileUploadedPath);

    } catch (e){

        var msg = "Error while building docker file";
        addEvent(DOCKER_IMAGE_BUILD, EVENT_FAILED, msg, versionHashId);

        try {
            ApplicationManager.updateVersionStatus(versionHashId, APPLICATION_ERROR);
        } catch(e1){
            log.error("Error while updating Application Creation Failed event for application : " + applicationName
                              + " version : " + versionName);
            log.error(e1);
            // not throwing the error, because it will hide the actual exception
        }

        log.error(msg);
        log.error(e);
        log.info("Application creation failed because dokcer image build failed and roll back process" +
                 " is started for application : "+applicationName+" with revision : "+versionName);
        deleteApplicationUploadedPath(applicationName, versionName);
        deleteApplicationFromDatabase(versionHashId);
        throw e;

    }

    //Adding docker build success event
    var msg = "Docker image build successfully built";
    addEvent(DOCKER_IMAGE_BUILD, EVENT_SUCCEEDED, msg, versionHashId);
}




var createAppInDataBase = function(applicationName, versionName, applicationDescription, replicas, runtimeId,
                                   appTypeName, runtimePropertiesArray, tagArray, appIcon, applicationHashId, versionHashId){

    //================================= Adding application to Database =========================================
    var application = new Application();
    var version = new Version();

    try {
        application.setApplicationName(applicationName);
        application.setHashId(applicationHashId);
        application.setDescription(applicationDescription);
        application.setApplicationType(appTypeName);

        var iconStream = null;
        var iconBlob = null;
        if (appIcon) {
            iconStream = Packages.org.apache.commons.io.IOUtils.toByteArray(appIcon.getStream().getStream());
            iconBlob = new Packages.javax.sql.rowset.serial.SerialBlob(iconStream);
            application.setIcon(iconBlob);
        }

        version.setVersionName(versionName);
        version.setRuntimeId(runtimeId);
        version.setStatus(APPLICATION_CREATED);
        version.setHashId(versionHashId);

        if(runtimePropertiesArray.length > 0) {
            var runtimePropertyList = generateRuntimePropsList(runtimePropertiesArray);
            version.setRuntimeProperties(runtimePropertyList);
        }

        if(tagArray.length > 0){
            var tagList = generateTagsList(tagArray);
            version.setTags(tagList);
        }

        var versionList = new java.util.ArrayList();
        versionList.add(version);
        application.setVersions(versionList);

        ApplicationManager.addApplication(application);

    } catch (e){

        var msg = "Error while adding application to database";
        addEvent(DATABASE_ADD, EVENT_FAILED, msg, versionHashId);

        try {
            ApplicationManager.updateVersionStatus(versionHashId, APPLICATION_ERROR);
        } catch (e1){
            log.error("Error while updating Application Creation Failed event for application : " + applicationName
                              + " version : " + versionName);
            log.error(e1);
            // not throwing the error, because it will hide the actual exception
        }

        log.error(msg);
        log.error(e);
        log.info("Application creation failed because initial application metadata persistence failed and roll back process" +
                 " is started for application : "+applicationName+" with version : "+ versionName);
        deleteApplicationUploadedPath(applicationName, versionName);
        throw e;
    }
    return application;
}


var createDockerFileForGitHub =  function(applicationName, versionName, runtimeId, gitHubRepoUrl, gitHubRepoBranch, versionHashId, dockerOpClient){
    //==================================== Create docker file block ==============================================
    //Adding docker file create pending event
    var msg = "Docker file creation successfully triggered in appcloud";
    addEvent(DOCKER_FILE_CREATE, EVENT_PENDING, msg, versionHashId);
    var absFileUploadedPath;

    try {
        var fileUploadPath = constructFileUploadPath(applicationName, versionName);
        var absFileUploadedPath = modManager.getPropertyValue(PROPERTY_APPMGT_DEPLOYMENT_DIR_PATH) + fileUploadPath;
        var dockerFilePath = absFileUploadedPath + DOCKER_FILE_NAME;

        var dockerTemplateFilePath = modManager.getPropertyValue(PROPERTY_APPMGT_DEPLOYMENT_DIR_PATH) + "/" + "DockerFiles/GitHub";
        dockerOpClient.createDockerFileForGitHub(runtimeId, gitHubRepoUrl, gitHubRepoBranch, dockerFilePath,dockerTemplateFilePath);
    } catch(e){
        var msg = "Error while creating docker file";
        addEvent(DOCKER_FILE_CREATE, EVENT_FAILED, msg, versionHashId);

        try {
            ApplicationManager.updateVersionStatus(versionHashId, APPLICATION_ERROR);
        } catch(e1){
            log.error("Error while updating Application Creation Failed event for application : " + applicationName
                              + " version : " + versionName);
            log.error(e1);
            // not throwing the error, because it will hide the actual exception
        }

        log.error(msg);
        log.error(e);
        log.info("Application creation failed because docker file creation failed and roll back process" +
                 " is started for application : "+applicationName+" with revision : "+versionName);
        deleteApplicationUploadedPath(applicationName, versionName);
        deleteApplicationFromDatabase(versionHashId);
        throw e;
    }

    //Adding docker file create success event
    var msg = "Docker file successfully created for application";
    addEvent(DOCKER_FILE_CREATE, EVENT_SUCCEEDED, msg, versionHashId);
    return absFileUploadedPath;
}

var createDockerFile =  function(applicationName, versionName, runtimeId, uploadedFileName, versionHashId, dockerOpClient){
    //==================================== Create docker file block ==============================================
    //Adding docker file create pending event
    var msg = "Docker file creation successfully triggered in appcloud";
    addEvent(DOCKER_FILE_CREATE, EVENT_PENDING, msg, versionHashId);
    var absFileUploadedPath;

    try {
        var fileUploadPath = constructFileUploadPath(applicationName, versionName);
        var absFileUploadedPath = modManager.getPropertyValue(PROPERTY_APPMGT_DEPLOYMENT_DIR_PATH) + fileUploadPath;
        var dockerFilePath = absFileUploadedPath + DOCKER_FILE_NAME;

        var dockerTemplateFilePath = modManager.getPropertyValue(PROPERTY_APPMGT_DEPLOYMENT_DIR_PATH) + "/" + "DockerFiles";

        var uploadArtifactTmpName;
        var checkFileExtZIP = isFileExtZIP(uploadedFileName);
        if (checkFileExtZIP) {
            var fileName = uploadedFileName.substring(0, uploadedFileName.lastIndexOf("."));
            uploadArtifactTmpName = fileName + FILE_EXTENSTION_ALTER;
        } else {
            uploadArtifactTmpName = uploadedFileName;
        }
        dockerOpClient.createDockerFile(runtimeId, uploadArtifactTmpName, dockerFilePath,dockerTemplateFilePath);

    } catch(e){
        var msg = "Error while creating docker file";
        addEvent(DOCKER_FILE_CREATE, EVENT_FAILED, msg, versionHashId);

        try {
            ApplicationManager.updateVersionStatus(versionHashId, APPLICATION_ERROR);
        } catch(e1){
            log.error("Error while updating Application Creation Failed event for application : " + applicationName
                              + " version : " + versionName);
            log.error(e1);
            // not throwing the error, because it will hide the actual exception
        }

        log.error(msg);
        log.error(e);
        log.info("Application creation failed because docker file creation failed and roll back process" +
                 " is started for application : "+applicationName+" with revision : "+versionName);
        deleteApplicationUploadedPath(applicationName, versionName);
        deleteApplicationFromDatabase(versionHashId);
        throw e;
    }

    //Adding docker file create success event
    var msg = "Docker file successfully created for application";
    addEvent(DOCKER_FILE_CREATE, EVENT_SUCCEEDED, msg, versionHashId);
    return absFileUploadedPath;
}

var deployApplication = function(applicationName, versionName, deploymentConfig, isRedeploy, versionHashId){

    //Adding deployment pending event
    var msg = "Application deployment successfully triggered in Kubernetes";
    addEvent(KUBE_DEPLOY, EVENT_PENDING, msg, versionHashId);

    applicationName = Util.getRuntimeValidAppName(applicationName);
    //Creating basic deployment
    var KubernetesRuntime = Packages.org.wso2.appcloud.provisioning.runtime.KubernetesRuntimeProvisioningService;

    var applicationCtx = KubernetesProvisioningUtils.getApplicationContext(
            applicationName, versionName, null , modManager.getTenantId(), modManager.getTenantDomain());
    var kubService = new KubernetesRuntime(applicationCtx);

    log.info("Deploying application: " + applicationName);
    try{
        kubService.deployApplication(deploymentConfig);
        if(!isRedeploy) {
            persistDeploymentConfig(deploymentConfig, versionHashId);
        }

    } catch(e){
        var msg = "Error while submitting application deployment to Kubernetes";
        addEvent(KUBE_DEPLOY, EVENT_FAILED, msg, versionHashId);
        ApplicationManager.updateVersionStatus(versionHashId, APPLICATION_ERROR);
        log.error(msg);
        log.error(e);
        log.info("Application deployment failed because kubernetes deployment was failed and roll back process" +
                 " is started for application:"+applicationName+" with revision:"+versionName);
        deleteApplicationUploadedPath(applicationName, versionName);
        deleteApplicationFromDatabase(versionHashId);
        throw e;
    }
    //Adding deployment success event
    var msg = "Application deployment successfull";
    addEvent(KUBE_DEPLOY, EVENT_SUCCEEDED, msg, versionHashId);
    //============================================================================================================

    //======================================= Creating Ingress ===================================================
    //Adding deployment pending event
    var msg = "Application ingress creation successfully triggered in Kubernetes";
    addEvent(INGRESS, EVENT_PENDING, msg, versionHashId);
    try{
        var appLaunchURL = constructAppLaunchURL(applicationName, versionName);

        var ingressCreated = kubService.createDeploymentUrl(appLaunchURL);
        log.info("Deployment URL status: " + ingressCreated);
        var msg = "Application ingress creation successful";
        addEvent(INGRESS, EVENT_SUCCEEDED, msg, versionHashId);
    } catch(e){
        var msg = "Application ingress creation failed in Kubernetes";
        addEvent(INGRESS, EVENT_FAILED, msg, versionHashId);
        ApplicationManager.updateVersionStatus(versionHashId, APPLICATION_ERROR);
        log.info("Application deployment failed because ingress is not created successfully and roll back process" +
                 " is started for application:"+applicationName+" with revision:"+versionName);
        deleteApplicationUploadedPath(applicationName, versionName);
        deleteApplicationFromDatabase(versionHashId);
        deleteApplicationFromKubernetes(applicationName, versionName);
        log.error(msg);
        log.error(e);
        throw e;
    }
    //======================================= checking pod status =================================================
    //Adding pod status pending event
    var msg = "Application pods Scheduled";
    var podStatus = KubernetesProvisioningUtils.getPodStatus(applicationCtx);
    var prevPodStatus = "";
    addEvent(POD_STATUS, EVENT_PENDING, podStatus, versionHashId);

    var counter = 0;
    while(counter < 300){ // Waiting 5 minutes to gets pods up and running
        java.lang.Thread.sleep(1000);
        var podStatus = KubernetesProvisioningUtils.getPodStatus(applicationCtx);
        counter = counter + 1;
        if (podStatus == "Running") {
            //Adding pod status pending event
            var msg = "Application started successfully";
            addEvent(POD_STATUS, EVENT_SUCCEEDED, podStatus, versionHashId);
            ApplicationManager.updateVersionStatus(versionHashId,APPLICATION_RUNNING);
            break;
        }else if(counter == 300){ // if pods doesn't starts withing 5 minutes user redirected to user home
            //Adding pod status error event
            var msg = "Application starting failed";
            var podStatus = KubernetesProvisioningUtils.getPodStatus(applicationCtx);
            addEvent(POD_STATUS, EVENT_FAILED, podStatus, versionHashId);
            ApplicationManager.updateVersionStatus(versionHashId, APPLICATION_ERROR);
            log.info("Application rollback started for application:"+applicationName + " with revision:"+
                     versionName +" because pods are not running even after 3 minutes.");
            deleteApplicationUploadedPath(applicationName, versionName);
            deleteDeployment(applicationName, versionName);
            deleteApplicationFromDatabase(versionHashId);
            deleteApplicationFromKubernetes(applicationName, versionName);
        } else {
            var podStatus = KubernetesProvisioningUtils.getPodStatus(applicationCtx);
            if (podStatus !== prevPodStatus) {
                addEvent(POD_STATUS, EVENT_PENDING, podStatus, versionHashId);
                prevPodStatus = podStatus;
            }
        }
    }
};

var constructAppLaunchURL = function(applicationName, versionName){

    applicationName = Util.getRuntimeValidAppName(applicationName);
    applicationName = applicationName.toLowerCase();

    var urlPrefix = modManager.getTenantDomain()
                            + "-" + applicationName + "-" + versionName;
    var appLaunchURL = urlPrefix.replace(/\./g, '-')
                               +  "." + modManager.getPropertyValue("ApplicationLaunchBaseURL");

    log.info("Application Launch URL: " + appLaunchURL);

    return appLaunchURL;
};

var deleteDeployment = function(versionHashId){
    ApplicationManager.deleteDeployment(versionHashId);
};

var updateApplicationStatus = function(versionHashId, status){
    ApplicationManager.updateVersionStatus(versionHashId, status);
};

var redeployApplication = function(applicationName, versionName, versionHashId){
    var deploymentConfig = buildDeploymentConfigFromDB(versionHashId);
    deployApplication(applicationName, versionName, deploymentConfig, true, versionHashId);
};
var persistDeploymentConfig = function(deploymentConfig, versionHashId){

    var containerList = deploymentConfig.getContainers();
    var ctr = containerList.get(0);
    var serviceProxies = ctr.getServiceProxies();
    var svc = serviceProxies.get(0);

    var deployment = new Deployment();
    deployment.setDeploymentName(deploymentConfig.getDeploymentName());
    log.info("Deployment name:" + deploymentConfig.getDeploymentName());
    deployment.setReplicas(parseInt(deploymentConfig.getReplicas()));
    log.info("Replicas:" + deploymentConfig.getReplicas());

    var serviceProxy = new ServiceProxy();
    serviceProxy.setServiceName(svc.getServiceName());
    log.info("Service name:" + svc.getServiceName());
    serviceProxy.setServiceProtocol(svc.getServiceProtocol());
    log.info("Service protocol:" + svc.getServiceProtocol());
    serviceProxy.setServicePort(svc.getServicePort());
    log.info("Service port:" + svc.getServicePort());
    serviceProxy.setServiceBackendPort(svc.getServiceBackendPort());
    log.info("Service Backend Port:" + svc.getServiceBackendPort());

    var container = new Container();
    container.setImageName(ctr.getBaseImageName());
    log.info("Image name:" + ctr.getBaseImageName());
    container.setImageVersion(ctr.getBaseImageVersion());
    log.info("Image version:" + ctr.getBaseImageVersion());

    var proxies = new java.util.HashSet();
    proxies.add(serviceProxy);
    container.setServiceProxies(proxies);

    var containerSet = new java.util.HashSet();
    containerSet.add(container);
    deployment.setContainers(containerSet);
    ApplicationManager.addDeployment(versionHashId, deployment );
};

var buildDeploymentConfigFromDB = function(versionHashId){
    var deployment = ApplicationManager.getDeployment(versionHashId);

    var deploymentConfig = new Packages.org.wso2.appcloud.provisioning.runtime.beans.DeploymentConfig();
    deploymentConfig.setDeploymentName(deployment.getDeploymentName());
    deploymentConfig.setReplicas(parseInt(deployment.getReplicas()));

    var deploymentContainers = deployment.getContainers();
    var provisioningContainerList = new java.util.ArrayList();
    var containerIterator = deploymentContainers.iterator();
    while(containerIterator.hasNext()){
        var deploymentContainer = containerIterator.next();
        var provisioningContainer = new Packages.org.wso2.appcloud.provisioning.runtime.beans.Container();
        provisioningContainer.setContainerName(versionHashId);
        provisioningContainer.setBaseImageName(deploymentContainer.getImageName());
        provisioningContainer.setBaseImageVersion(deploymentContainer.getImageVersion());

        //Adding runtime properties to k8 container
        var runtimeProperties = deploymentContainer.getRuntimeProperties();
        var envs = getRuntimeProperties(runtimeProperties);
        provisioningContainer.setEnvVariables(envs);

        var deploymentProxies = deploymentContainer.getServiceProxies();
        var provisioningProxyList = new java.util.ArrayList();
        var proxyIterator = deploymentProxies.iterator();
        while(proxyIterator.hasNext()){
            var deploymentProxy = proxyIterator.next();
            var provisioningProxy = new Packages.org.wso2.appcloud.provisioning.runtime.beans.ServiceProxy();
            provisioningProxy.setServiceName(deploymentProxy.getServiceName());
            provisioningProxy.setServiceProtocol(deploymentProxy.getServiceProtocol());
            provisioningProxy.setServicePort(deploymentProxy.getServicePort());
            provisioningProxy.setServiceBackendPort(parseInt(deploymentProxy.getServiceBackendPort()));
            provisioningProxyList.add(provisioningProxy);
        }
        provisioningContainer.setServiceProxies(provisioningProxyList);
        provisioningContainerList.add(provisioningContainer);
    }
    deploymentConfig.setContainers(provisioningContainerList);

    return deploymentConfig;

};

/**
 * Method for getting all the available application types. e.g : war, mss, car
 */
function getContainers(tenantDockerRegistryUrl, baseImageName, tag, versionHashId, appServiceName, runtimeProperties, runtimeId){
    var containerList = new java.util.ArrayList();
    var container = new Packages.org.wso2.appcloud.provisioning.runtime.beans.Container();
    var appBaseImageName = tenantDockerRegistryUrl + "/" + baseImageName;
    container.setContainerName(versionHashId);
    container.setBaseImageName(appBaseImageName);
    container.setBaseImageVersion(tag);
    var envs = getRuntimeProperties(runtimeProperties);
    container.setEnvVariables(envs);
    var serviceProxyList = new java.util.ArrayList();
    var services = ApplicationManager.getTransportsForRuntime(runtimeId);

    for(var i = 0; i < services.length; i++){
        var serviceProxy = new Packages.org.wso2.appcloud.provisioning.runtime.beans.ServiceProxy();
        var service = services[i];
        serviceProxy.setServiceName('srv-' + appServiceName);
        serviceProxy.setServiceProtocol(service.getServiceProtocol());
        serviceProxy.setServicePort(getIngressPort(service.getServiceName()));
        serviceProxy.setServiceBackendPort(service.getServicePort());
        serviceProxyList.add(serviceProxy);
    }
    container.setServiceProxies(serviceProxyList);
    containerList.add(container);

    return containerList;
};

function getRuntimeProperties(runtimeProperties){
    //setting runtime properties to the container
    var envs = new java.util.HashMap();
    if(runtimeProperties) {
        var runtimePropertyIterator = runtimeProperties.iterator();
        while (runtimePropertyIterator.hasNext()) {
            var runtimeProperty = runtimePropertyIterator.next();
            envs.put(runtimeProperty.getPropertyName(), runtimeProperty.getPropertyValue());
        }
    }
    return envs;
}

function getDeploymentConfig(containersList, versionHashId, replicas){

    var deploymentConfig = new Packages.org.wso2.appcloud.provisioning.runtime.beans.DeploymentConfig();
    deploymentConfig.setDeploymentName(versionHashId);
    deploymentConfig.setReplicas(parseInt(replicas));
    deploymentConfig.setContainers(containersList);

    return deploymentConfig;
}

/**
 * Method for getting all the available application types e.g : war, mss, car
 */
var getAllAppTypes = function(){

    var appTypeArray = [];

    try {
        var appTypes = ApplicationManager.getAllAppTypes();

        for (var i = 0; i < appTypes.length; i++) {
            var appType = appTypes[i];
            var appTypeObject = {};

            appTypeObject.name = appType.appTypeName;
            appTypeObject.description = appType.description;

            appTypeArray.push(appTypeObject);
        }
    } catch(e){
        log.error("Error while getting the list of apptypes");
        log.error(e);
        throw e;
    }

    return appTypeArray;
};

/**
 * Method for getting all the available runtimes e.g : tomcat, wso2as
 * @param appType application type
 */
var getAllRuntimes = function(appType){

    var runtimeArray = [];

    try {
        var runtimes = ApplicationManager.getAllRuntimesForAppType(appType);

        for(var i = 0; i < runtimes.length; i++){
            var runtime = runtimes[i];
            var runtimeObject = {};

            runtimeObject.id = runtime.id;
            runtimeObject.runtimeName = runtime.runtimeName;
            runtimeObject.imageName = runtime.imageName;
            runtimeObject.repoURL = runtime.repoURL;
            runtimeObject.tag = runtime.tag;

            runtimeArray.push(runtimeObject);
        }
    } catch(e){
        log.error("Error while getting the list of runtimes");
        log.error(e);
        throw e;
    }

    return runtimeArray;
}

/**
 * Method for getting the application summery of all the applications
 */
var getAllApplications = function(){
    var applicationArray = [];
    try {
        var applications = ApplicationManager.getApplicationList();
        var appTypePropertyConfPath = jagg.getAppTypePropertyConfFilePath();
        var parsedObject = parse(appTypePropertyConfPath);
        var appTypesProperties = require(parsedObject);

        for (var i = 0; i < applications.length; i++) {
            var application = applications[i];
            var applicationObject = {};

            applicationObject.applicationName = application.applicationName;
            applicationObject.hashId = application.hashId;
            applicationObject.applicationType = application.applicationType;
            applicationObject.icon = getApplicationIconAsBase64String(application);
            applicationObject.appTypeIcon = appTypesProperties[application.applicationType].icon;
            applicationObject.appTypeTitle = appTypesProperties[application.applicationType].displayName;
            applicationArray.push(applicationObject);
        }
    } catch(e){
        log.error("Error while getting the application list");
        log.error(e);
        throw e;
    }

    return applicationArray;
}

var getApplicationHashId = function(applicationName){
    var tenantId = modManager.getTenantId();
    return Util.getApplicationHashId(applicationName, tenantId);
}


var getApplicationHashIdByName = function(applicationName){
    return ApplicationManager.getApplicationHashIdByName(applicationName);
}

/**
 * Method for getting the application e.g. :- Application {
 *                                              id=1,
 *                                              applicationName="fooApp",
 *                                              revision="1.0.0",
 *                                              runtimeName= "WSO2AS",
 *                                              status = "Running",
 *                                              numberOfReplicas=2
 *                                              description="this is fooApp java application"
 *                                              }
 */
var getApplication = function(applicationHashId){
    try {
        var application = ApplicationManager.getApplicationByHashId(applicationHashId);
        var applicationObject = {};

        applicationObject.applicationName = application.applicationName;
        applicationObject.hashId = application.hashId;
        applicationObject.description = application.description;
        applicationObject.defaultVersion = application.versions.get(0).versionName;
        applicationObject.applicationType = application.applicationType;
        applicationObject.icon = getApplicationIconAsBase64String(application);
        applicationObject.versions = generateVersionList(application.versions, application.applicationName);
    } catch(e){
        log.error("Error while getting the application");
        log.error(e);
        throw e;
    }

    return applicationObject;
}

var generateVersionList = function (versions, applicationName){
    var versionList = {};
    try {
        for (var i = 0; i < versions.size(); i++) {
            var versionObject = {};
            var version = versions.get(i);
            var deploymentUrl = getDeploymentURL(applicationName, version.versionName);

            versionObject.versionName = version.versionName;
            versionObject.hashId = version.hashId;
            versionObject.runtimeId = version.runtimeId;
            versionObject.runtimeName = version.runtimeName;
            versionObject.status = version.status;
            versionObject.runtimeProperties = generateRuntimePropsArray(version.runtimeProperties);
            versionObject.tags = generateTagsArray(version.tags);
            versionObject.deploymentURL = deploymentUrl;

            versionList[version.versionName] = versionObject;
        }
    } catch(e){
        log.error("Error while getting the application list");
        log.error(e);
        throw e;
    }
    return versionList;
}


/**
 * Get application icon as a base64 encoded string.
 *
 * @return base64 encoded string, null if icon is null
 */
function getApplicationIconAsBase64String(application) {
    var icon = null;
    if(application.icon){
        icon = Packages.org.apache.commons.codec.binary.Base64.
                encodeBase64String(application.icon.getBytes(1, application.icon.length()));
    }
    return icon;
}

/**
 * Update application icon
 *
 * @param applicationKey application key
 * @param appIcon file object of the appIcon
 */
function changeApplicationIcon(applicationHashId, appIcon){
    if(appIcon){
        var streamHostObject = appIcon.getStream();
        var inputStream = streamHostObject.getStream();
        ApplicationManager.updateApplicationIcon(applicationHashId, inputStream);
    } else {
        log.error("Provided app icon is Empty for application : "+applicationName);
        throw "Provided app icon is Empty"
    }

}

var getEnvVariablesOfVersion = function(versionHashId){

    var evnVariables = [];
    try {
        var envVars = ApplicationManager.getAllRuntimePropertiesOfVersion(versionHashId);
        for (var i = 0; i < envVars.size(); i++) {
            var envObj = {};
            envObj.key = envVars.get(i).propertyName;
            envObj.value = envVars.get(i).propertyValue;
            evnVariables.push(envObj);
        }
    } catch(e){
        log.error("Error while getting the application");
        log.error(e);
        throw e;
    }
    return evnVariables;
};

var getTags = function(versionHashId){
    var tags = [];
    try {
        var tagArr = ApplicationManager.getAllTagsOfVersion(versionHashId);
        for (var i = 0; i < tagArr.size(); i++) {
            var tagObj = {};
            tagObj.key = tagArr.get(i).tagName;
            tagObj.value = tagArr.get(i).tagValue;
            tags.push(tagObj);
        }
    } catch(e){
        log.error("Error while getting the application");
        log.error(e);
        throw e;
    }
    return tags;
};

var updateTag = function (versionHashId, prevKey, newKey, newValue) {
    try {
        ApplicationManager.updateTag(versionHashId, prevKey, newKey, newValue);
    } catch (e) {
        log.error("Error while getting the application");
        log.error(e);
        throw e;
    }
};
var updateRuntimeProperty = function (versionHashId, prevKey, newKey, newValue) {
    try {
        ApplicationManager.updateRuntimeProperty(versionHashId, prevKey, newKey, newValue);
    } catch (e) {
        log.error("Error while getting the application");
        log.error(e);
        throw e;
    }
};

var deleteRuntimeProperty = function (versionHashId, key) {
    try {
        ApplicationManager.deleteRuntimeProperty(versionHashId, key);
    } catch (e) {
        log.error("Error while getting the application");
        log.error(e);
        throw e;
    }
};
var deleteTag = function (versionHashId, key) {
    try {
        ApplicationManager.deleteTag(versionHashId, key);
    } catch (e) {
        log.error("Error while getting the application");
        log.error(e);
        throw e;
    }
};
var addRuntimeProperty = function (versionHashId, key, value) {
    try {
        var runtimePropertyList = new java.util.ArrayList();
        var runtimeProperty = new Packages.org.wso2.appcloud.core.dto.RuntimeProperty();
        runtimeProperty.setPropertyName(key);
        runtimeProperty.setPropertyValue(value);
        runtimePropertyList.add(runtimeProperty);
        ApplicationManager.addRuntimeProperties(runtimePropertyList, versionHashId);
    } catch (e) {
        log.error("Error while adding runtime property with Key:" + key);
        log.error(e);
        throw e;
    }
};

var addTag = function (versionHashId, key, value) {
    try {
        var tagList = new java.util.ArrayList();
        var tag = new Packages.org.wso2.appcloud.core.dto.Tag();
        tag.setTagName(key);
        tag.setTagValue(value);
        tagList.add(tag);
        ApplicationManager.addTags(tagList, versionHashId);
    } catch (e) {
        log.error("Error while adding runtime property with Key:" + key);
        log.error(e);
        throw e;
    }
};

var generateTagsList = function (tagListArray) {
    try {
        var size = tagListArray.length;
        var tagList = new java.util.ArrayList();
        for (var i = 0; i < size; i++) {
            var tagJsonObj = tagListArray[i];
            var tag = new Packages.org.wso2.appcloud.core.dto.Tag();
            tag.setTagName(tagJsonObj.key);
            tag.setTagValue(tagJsonObj.value);
            tagList.add(tag);
        }
        return tagList;
    } catch (e) {
        log.error("Error while adding tags : ");
        log.error(tagListArray);
        log.error(e);
        throw e;
    }
};

var generateRuntimePropsList = function (runtimePropsArray) {
    try {
        var size = runtimePropsArray.length;
        var propsList = new java.util.ArrayList();
        for (var i = 0; i < size; i++) {
            var runtimePropJsonObj = runtimePropsArray[i];
            var runtimeProperty = new RuntimeProperty();
            runtimeProperty.setPropertyName(runtimePropJsonObj.key);
            runtimeProperty.setPropertyValue(runtimePropJsonObj.value);
            propsList.add(runtimeProperty);
        }
        return propsList;
    } catch (e) {
        log.error("Error while adding runtime props : ");
        log.error(propsList);
        log.error(e);
        throw e;
    }
};

var generateRuntimePropsArray=function(runtimeList){
    var size = runtimeList.size();
    var runtimePropsArray = [];
    for (var i = 0; i < size; i++) {
        var runtimePropObject = runtimeList.get(i);
        var runtimeProperty = {
            id: runtimePropObject.id,
            propertyName: runtimePropObject.propertyName,
            propertyValue: runtimePropObject.propertyValue,
            description: runtimePropObject.propertyValue
        };
        runtimePropsArray.push(runtimeProperty);
    }
    return runtimePropsArray;
};

var generateTagsArray=function(labelsList){
    var size = labelsList.size();
    var labelsArray = [];
    for (var i = 0; i < size; i++) {
        var labelObject = labelsList.get(i);
        var label = {
            labelName: labelObject.tagName,
            labelValue: labelObject.tagValue,
            description: labelObject.description
        };
        labelsArray.push(label);
    }
    return labelsArray;
};


var getVersionListOfApplication = function(applicationHashId){
    var revisionArray = [];
    try {
        var revisions = ApplicationManager.getVersionListOfApplication(applicationHashId);
        for (var i = 0; i < revisions.size(); i++) {
            revisionArray.push(revisions.get(i));
        }
    } catch(e){
        log.error("Error while getting the application list");
        log.error(e);
        throw e;
    }
    return revisionArray;
};

var getDeploymentURL = function (applicationName, versionName){

    var urlScheme = CloudUtil.getPropertyValue("DeploymentUrlScheme");
    var baseURL = constructAppLaunchURL(applicationName, versionName);
    var applicationLaunchURL = urlScheme + "://" + baseURL;

    log.debug("Deployment URL: " + applicationLaunchURL);
    return applicationLaunchURL;
};


var putSelectedRevisionToSession = function(applicationKey, currentRevision) {
    var selectedVersions = session.get("SELECTED_REVISIONS");
    if (!selectedVersions) {
        selectedVersions = {};
    }
    selectedVersions[applicationKey] = currentRevision;
    session.put("SELECTED_REVISIONS", selectedVersions);
};

var getSelectedRevisionFromSession = function(applicationKey) {
    var selectedVersions = session.get("SELECTED_REVISIONS");
    if (selectedVersions && selectedVersions[applicationKey]) {
        return selectedVersions[applicationKey];
    } else {
        return null;
    }
};

var getApplicationCreationEvents = function(applicationName, versionName) {

    var tenantId = modManager.getTenantId();
    var versionHashId = Util.getVersionHashId(applicationName, versionName, tenantId);

    var eventsManager = new EventsManager();
    var eventsArray = [];

    try {
        var events = eventsManager.getEventsOfApplication(versionHashId);
        for (var i = 0; i < events.length; i++) {
            var event = events[i];
            var eventObject = {};

            eventObject.name = event.eventName;
            eventObject.status = event.eventStatus;
            eventObject.timestamp = event.timestamp;
            eventObject.description = event.eventDescription;

            eventsArray.push(eventObject);
        }
    } catch(e){
        log.error("Error while getting the application creation event list");
        log.error(e);
        throw e;
    }
    return eventsArray;

    var events = eventsManager.getEventsOfApplication(versionHashId);
};

var uploadExistingArchive = function(uploadedArtifact, appTypeName, applicationName, revision){
    createDestinationDirsForUploadedApps(applicationName, revision);
    var file = Packages.java.io.File;
    uploadedFileName = uploadedArtifact.getName();
    var fileUploadPath = constructFileUploadPath(applicationName, revision);

    var uploadApplicationTmpPath;
    var checkFileExtZIP = isFileExtZIP(uploadedFileName);
    //.zip files are auto extracted inside the AS. So if file extension is zip, then extension change to .upload.
    if(checkFileExtZIP){
        var fileName = uploadedFileName.substring(0, uploadedFileName.lastIndexOf("."));
        uploadApplicationTmpPath = fileUploadPath + fileName + FILE_EXTENSTION_ALTER;
        log.info(uploadApplicationTmpPath);
    }else{
        uploadApplicationTmpPath = fileUploadPath + uploadedFileName;
        log.info(uploadApplicationTmpPath);
    }

    uploadedArtifact.move(uploadApplicationTmpPath);
};

var isFileExtZIP = function(uploadedFileName){
    var fileExt = uploadedFileName.substr(uploadedFileName.lastIndexOf(".") + 1, uploadedFileName.length);
    if(fileExt == FILE_EXTENTION_ZIP){
        return true;
    }
    return false;
};

var createDestinationDirsForUploadedApps = function (applicationName, revision) {
    var fileUtils = Packages.org.apache.commons.io.FileUtils;
    var absFileUploadPath = modManager.getPropertyValue(PROPERTY_APPMGT_DEPLOYMENT_DIR_PATH) +
                            constructFileUploadPath(applicationName, revision);
    var uploadedFilePath = new Packages.java.io.File(absFileUploadPath);
    try {
        fileUtils.forceMkdir(uploadedFilePath);
    } catch (e) {
        log.error("Error while creating the directory : " + absFileUploadPath);
        log.error(e);
    }

};

var downloadFromUrl = function(artifactUrl,applicationName, revision, apptype){
    log.info("Inside modules downloadFromUrl");
    createDestinationDirsForUploadedApps(applicationName, revision);
    var fileUploadPath = constructFileUploadPath(applicationName, revision);
    var CARBON_HOME = CarbonUtils.getCarbonHome();
    var filePath = CARBON_HOME + "/repository/deployment/server/jaggeryapps/appmgt";

    if (apptype == "war"){
        filePath  = filePath + fileUploadPath + applicationName + ".war";
    } else if (apptype == "mss") {
        filePath  = filePath + fileUploadPath + applicationName + ".jar";
    }
    log.info("apptype: " + apptype);
    CloudUtil.downloadFromUrl(artifactUrl , filePath);
};

var addEvent = function(name, status, description, versionHashId) {
    try {
        var eventsManager = new EventsManager();
        var event = new Event();

        event.setEventName(name);
        event.setEventStatus(status);
        event.setTimestamp(new Packages.java.sql.Timestamp(new Date().getTime()));
        event.setEventDescription(description);
        eventsManager.addAppCreationEvent(versionHashId, event);
    } catch (e) {
        log.error("Error while adding app creation event for application with version hash id : "+versionHashId + " with version hash Id :"
                          + versionHashId+" event name:"+name+" ,event status:"+status+" ,event description:"+description);
        log.error(e);
        // not throwing error, because it will affect the application creation process
    }
};

var deleteApplicationUploadedPath = function(applicationName, revision) {
    var fileUploadPath = constructFileUploadPath(applicationName, revision);
    var fileUtils = Packages.org.apache.commons.io.FileUtils;
    var file = new Packages.java.io.File(fileUploadPath);

    if(fileUploadPath.exists()){
        //Commenting deleting upload path inorder to work retry app deployment correctly.
        // Upload path clean up force to upload the artifact again in the retying.
        //fileUtils.deleteDirectory(fileUploadPath);
    }
};

var deleteApplicationFromDatabase = function (versionHashId) {
    try {
        java.lang.Thread.sleep(3000); // database at last after the transaction completes.
        ApplicationManager.deleteVersion(versionHashId);
    } catch (e) {
        log.error("Error while deleting application from the database with versionHashId : " + versionHashId);
        throw e;
    }
};

var deleteApplicationFromKubernetes = function (applicationName, revision) {
    try {
        var KubernetesRuntimeProvisioningService =
                Packages.org.wso2.appcloud.provisioning.runtime.KubernetesRuntimeProvisioningService;

        var applicationCtx = new Packages.org.wso2.appcloud.provisioning.runtime.beans.ApplicationContext();
        applicationCtx.setId(applicationName);
        applicationCtx.setVersion(revision);
        var tenantInfo = new Packages.org.wso2.appcloud.provisioning.runtime.beans.TenantInfo();
        tenantInfo.setTenantId(modManager.getTenantId());
        tenantInfo.setTenantDomain(modManager.getTenantDomain());
        applicationCtx.setTenantInfo(tenantInfo);

        var kubernetesRuntimeProvisioningService = new KubernetesRuntimeProvisioningService(applicationCtx);

        kubernetesRuntimeProvisioningService.deleteDeployment();
    } catch (e) {
        log.error("Error while cleaning up the application : " + applicationName + " revision : " + revision
                + "Kubernetes deployment");
        throw e;
    }
};

var deleteApplication = function(applicationName) {
    var versions = getAllRevisionsOfApplication(applicationName);
    try{
        for (i = 0; i < versions.length; i++) {
            log.info("Deleting application: " + applicationName + ":" + versions[i]);
            deleteApplicationUploadedPath(applicationName, versions[i]);
            deleteApplicationFromDatabase(applicationName, versions[i]);
            deleteApplicationFromKubernetes(applicationName, versions[i]);
        }
    } catch(e){
        log.error("Error while cleaning up the Kubernetes deployment");
        log.error(e);
    }
};

var getIngressPort = function(serviceName){

    if(serviceName == "http" || serviceName == "http-alt"){
        return  80;
    }else if(serviceName == "https" || serviceName == "https-alt"){
        return 443;
    } else{
        return 80;
    }
};

var constructFileUploadPath = function (applicationName, revision) {
    var fileSeparator = Packages.java.io.File.separator;
    var fileUploadPath = fileSeparator + TMP_UPLOADED_APPLICATIONS_PATH + fileSeparator +
                         modManager.getTenantDomain() + fileSeparator + applicationName +
                         fileSeparator + revision + fileSeparator;
    return fileUploadPath;
};

%>